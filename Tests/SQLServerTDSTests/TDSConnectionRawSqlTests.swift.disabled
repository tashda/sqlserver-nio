@testable import SQLServerTDS
import XCTest
import NIOEmbedded
import Logging
import Foundation

final class TDSConnectionRawSqlTests: XCTestCase {
    private var channel: EmbeddedChannel!
    private var connection: TDSConnection!
    private var interceptor: TestRequestCaptureHandler!
    private var logger: Logger!

    override func setUpWithError() throws {
        try super.setUpWithError()
        channel = EmbeddedChannel()
        interceptor = TestRequestCaptureHandler()
        try channel.pipeline.addHandler(interceptor).wait()
        logger = Logger(label: "tds.rawsql.test")
        connection = TDSConnection(channel: channel, logger: logger)
    }

    override func tearDownWithError() throws {
        if let connection {
            var closed = false
            let closeFuture = connection.close()
            closeFuture.whenComplete { _ in closed = true }
            pumpEventLoop(until: { closed })
        }
        _ = try? channel.finish()
        channel = nil
        connection = nil
        interceptor = nil
        logger = nil
        try super.tearDownWithError()
    }

    func testRawSqlAggregatesRows() throws {
        let future = connection.rawSql("SELECT 1;")
        var isComplete = false
        future.whenComplete { _ in isComplete = true }

        guard let context = interceptor.lastRequest else {
            XCTFail("Expected RawSqlRequest to be sent")
            return
        }
        guard let request = context.delegate as? RawSqlRequest else {
            XCTFail("Expected RawSqlRequest delegate")
            return
        }

        let (row, _) = Self.makeSampleRow(value: "agg-value")
        request.onRow?(row)
        context.completionPromise.futureResult.eventLoop.execute {
            context.completionPromise.succeed(())
        }
        pumpEventLoop(until: { isComplete })

        XCTAssertTrue(isComplete, "Expected rawSql future to resolve")
        guard isComplete else { return }
        let rows = try future.wait()
        XCTAssertEqual(rows.count, 1)
        XCTAssertEqual(rows.first?.string, "agg-value")
    }

    func testRawSqlStreamingClosureReceivesRows() throws {
        var received: String?

        let request = RawSqlRequest(sql: "SELECT 1;") { row in
            received = row.data.first?.string
        }
        let future = connection.send(request, logger: logger)
        var isComplete = false
        future.whenComplete { _ in isComplete = true }

        guard let context = interceptor.lastRequest else {
            XCTFail("Expected RawSqlRequest to be sent")
            return
        }
        guard let req = context.delegate as? RawSqlRequest else {
            XCTFail("Expected RawSqlRequest delegate")
            return
        }

        let (row, _) = Self.makeSampleRow(value: "stream-value")
        req.onRow?(row)
        context.completionPromise.futureResult.eventLoop.execute {
            context.completionPromise.succeed(())
        }
        pumpEventLoop(until: { isComplete })

        XCTAssertTrue(isComplete, "Expected streaming future to resolve")
        guard isComplete else { return }
        XCTAssertEqual(received, "stream-value")
        XCTAssertNoThrow(try future.wait())
    }

    func testQueryWithExplicitMessageUsesProvidedBatch() throws {
        let message = TDSMessages.RawSqlBatchMessage(sqlText: "SELECT 2;")
        let request = RawSqlRequest(sql: message.sqlText)
        let future = connection.send(request, logger: logger)
        var isComplete = false
        future.whenComplete { _ in isComplete = true }

        guard let context = interceptor.lastRequest else {
            XCTFail("Expected RawSqlRequest to be sent")
            return
        }
        guard let req = context.delegate as? RawSqlRequest else {
            XCTFail("Expected RawSqlRequest delegate")
            return
        }

        XCTAssertEqual(req.sql, message.sqlText)

        context.completionPromise.futureResult.eventLoop.execute {
            context.completionPromise.succeed(())
        }
        pumpEventLoop(until: { isComplete })

        XCTAssertTrue(isComplete, "Expected query future to resolve")
        guard isComplete else { return }
        XCTAssertNoThrow(try future.wait())
    }

    // MARK: - Streaming Mode Tests (Step 1.1)

    func testRawSqlRequestStreamingFlagDefaultsToFalse() throws {
        let request = RawSqlRequest(sql: "SELECT 1;")

        XCTAssertFalse(request.stream, "RawSqlRequest should default to non-streaming mode")
        XCTAssertNil(request.onData, "RawSqlRequest should have nil onData callback by default")
    }

    func testRawSqlRequestStreamingModeEnabled() throws {
        var receivedData: [TDSData] = []
        let onDataCallback: (TDSData) -> Void = { data in
            receivedData.append(data)
        }

        let request = RawSqlRequest(
            sql: "SELECT 1;",
            stream: true,
            onData: onDataCallback
        )

        XCTAssertTrue(request.stream, "RawSqlRequest should have streaming enabled when specified")
        XCTAssertNotNil(request.onData, "RawSqlRequest should have onData callback when provided")
    }

    func testRawSqlRequestStreamingModeWithAllCallbacks() throws {
        var receivedRows: [TDSRow] = []
        var receivedData: [TDSData] = []
        var receivedMetadata: [[TDSTokens.ColMetadataToken.ColumnData]] = []
        var receivedDoneTokens: [TDSTokens.DoneToken] = []

        let onRowCallback: (TDSRow) -> Void = { row in
            receivedRows.append(row)
        }

        let onDataCallback: (TDSData) -> Void = { data in
            receivedData.append(data)
        }

        let onMetadataCallback: ([TDSTokens.ColMetadataToken.ColumnData]) -> Void = { metadata in
            receivedMetadata.append(metadata)
        }

        let onDoneCallback: (TDSTokens.DoneToken) -> Void = { doneToken in
            receivedDoneTokens.append(doneToken)
        }

        let request = RawSqlRequest(
            sql: "SELECT 1;",
            stream: true,
            onRow: onRowCallback,
            onData: onDataCallback,
            onMetadata: onMetadataCallback,
            onDone: onDoneCallback
        )

        XCTAssertTrue(request.stream, "RawSqlRequest should have streaming enabled")
        XCTAssertNotNil(request.onRow, "RawSqlRequest should have onRow callback")
        XCTAssertNotNil(request.onData, "RawSqlRequest should have onData callback")
        XCTAssertNotNil(request.onMetadata, "RawSqlRequest should have onMetadata callback")
        XCTAssertNotNil(request.onDone, "RawSqlRequest should have onDone callback")
    }

    func testRawSqlRequestBatchModeMaintainsExistingBehavior() throws {
        let request = RawSqlRequest(
            sql: "SELECT 1;",
            stream: false,  // Explicitly false
            onRow: { row in
                // Existing batch mode callback
            }
        )

        XCTAssertFalse(request.stream, "RawSqlRequest should maintain batch mode when stream=false")
        XCTAssertNil(request.onData, "RawSqlRequest should not need onData callback in batch mode")
        XCTAssertNotNil(request.onRow, "RawSqlRequest should still support onRow in batch mode")
    }

    func testRawSqlRequestNodeMssqlCompatibility() throws {
        // This test ensures our streaming API matches node-mssql patterns
        let streamingRequest = RawSqlRequest(
            sql: "SELECT * FROM large_table",
            stream: true,
            onData: { data in
                // Process individual data items immediately (like node-mssql row events)
            }
        )

        let batchRequest = RawSqlRequest(
            sql: "SELECT * FROM small_table",
            stream: false
        )

        // Verify the core difference: streaming vs batch mode
        XCTAssertTrue(streamingRequest.stream, "node-mssql: req.stream = true")
        XCTAssertFalse(batchRequest.stream, "node-mssql: req.stream = false (default)")

        // In node-mssql, streaming mode emits 'row' events immediately
        // Our onData callback provides the same immediate processing capability
        XCTAssertNotNil(streamingRequest.onData, "Should have immediate data processing like node-mssql events")
        XCTAssertNil(batchRequest.onData, "Batch mode doesn't need immediate processing")
    }

    // MARK: - Helpers

    private static func makeSampleRow(
        columnName: String = "Value",
        value: String
    ) -> (row: TDSRow, metadata: TDSTokens.ColMetadataToken) {
        let column = TDSTokens.ColMetadataToken.ColumnData(
            userType: 0,
            flags: 0,
            dataType: .nvarchar,
            length: value.utf16.count * 2,
            collation: [],
            tableName: nil,
            colName: columnName,
            precision: nil,
            scale: nil
        )
        let metadata = TDSTokens.ColMetadataToken(count: 1, colData: [column])

        var buffer = ByteBufferAllocator().buffer(capacity: value.utf16.count * 2)
        buffer.writeUTF16String(value)

        let columnData = TDSTokens.RowToken.ColumnData(
            textPointer: [],
            timestamp: [],
            data: buffer
        )

        let rowToken = TDSTokens.RowToken(colData: [columnData])
        let row = TDSRow(token: rowToken, columns: metadata.colData)

        return (row, metadata)
    }

    private func pumpEventLoop(
        until condition: @escaping () -> Bool,
        timeout: TimeInterval = 1.0
    ) {
        let deadline = Date().addingTimeInterval(timeout)
        while !condition() && Date() < deadline {
            channel.embeddedEventLoop.run()
        }
    }
}

private final class TestRequestCaptureHandler: ChannelDuplexHandler {
    typealias InboundIn = TDSPacket
    typealias OutboundIn = TDSRequestContext

    private(set) var requests: [TDSRequestContext] = []

    var lastRequest: TDSRequestContext? { requests.last }

    func write(context: ChannelHandlerContext, data: NIOAny, promise: EventLoopPromise<Void>?) {
        let request = unwrapOutboundIn(data)
        requests.append(request)
        promise?.succeed(())
    }

    func flush(context: ChannelHandlerContext) {
        context.flush()
    }
}
