@testable import SQLServerTDS
import XCTest
@preconcurrency import NIO
import NIOEmbedded
import Logging

final class TDSLoginDuplicateTests: XCTestCase, @unchecked Sendable {
    private func makeChannelWithRequestHandler() throws -> EmbeddedChannel {
        let channel = EmbeddedChannel()
        let logger = Logger(label: "tds.login.dup.tests")
        let firstDecoder = ByteToMessageHandler(TDSPacketDecoder(logger: logger))
        let firstEncoder = MessageToByteHandler(TDSPacketEncoder(logger: logger))
        let handler = TDSRequestHandler(
            logger: logger,
            firstDecoder: firstDecoder,
            firstEncoder: firstEncoder,
            tlsConfiguration: nil,
            serverHostname: nil,
            firstDecoderName: "tds.firstDecoder",
            firstEncoderName: "tds.firstEncoder",
            pipelineCoordinatorName: "tds.pipelineCoordinator"
        )
        try channel.pipeline.addHandler(firstDecoder, name: "tds.firstDecoder").wait()
        try channel.pipeline.addHandler(firstEncoder, name: "tds.firstEncoder").wait()
        try channel.pipeline.addHandler(handler, name: "tds.requestHandler").wait()
        return channel
    }

    func drainOutbound(_ channel: EmbeddedChannel) throws -> [ByteBuffer] {
        var out: [ByteBuffer] = []
        while let buf: ByteBuffer = try channel.readOutbound(as: ByteBuffer.self) {
            out.append(buf)
        }
        return out
    }

    func makeLoginRequestContext(on loop: EventLoop) -> TDSRequestContext {
        let payload = TDSMessages.Login7Message(
            username: "sa",
            password: "password",
            serverName: "server",
            database: "master",
            useIntegratedSecurity: false,
            sspiData: nil
        )
        let request = LoginRequest(payload: payload)
        let completionPromise: EventLoopPromise<Void> = PromiseTracker.makeTrackedPromise(on: loop, label: "TDSRequest.completion")
        let resultPromise: EventLoopPromise<[TDSData]> = PromiseTracker.makeTrackedPromise(on: loop, label: "TDSRequest.result")
        let tokenHandler = RequestTokenHandler(
            promise: completionPromise,
            onRow: request.onRow,
            onMetadata: request.onMetadata,
            onDone: request.onDone,
            onMessage: request.onMessage,
            onReturnValue: request.onReturnValue
        )
        return TDSRequestContext(
            delegate: request,
            completionPromise: completionPromise,
            resultPromise: resultPromise,
            tokenHandler: tokenHandler
        )
    }

    func testDuplicateLoginIsDroppedAndQueueProgresses() throws {
        let channel = try makeChannelWithRequestHandler()
        let ctx1 = makeLoginRequestContext(on: channel.eventLoop)
        let ctx2 = makeLoginRequestContext(on: channel.eventLoop)

        // Write first LOGIN
        try channel.writeAndFlush(ctx1).wait()
        let firstWrites = try drainOutbound(channel)
        XCTAssertFalse(firstWrites.isEmpty, "First LOGIN should emit packets")

        // Write duplicate LOGIN immediately; should be coalesced and not emit any additional outbound data
        try channel.writeAndFlush(ctx2).wait()
        let secondWrites = try drainOutbound(channel)
        XCTAssertTrue(secondWrites.isEmpty, "Duplicate LOGIN should not emit packets")

        // Duplicate request promise should be completed successfully
        XCTAssertNoThrow(try ctx2.completionPromise.futureResult.wait())

        // Finish channel cleanly
        XCTAssertNoThrow(_ = try channel.finish())
    }
}
